import numpy as np
from smarc_modelling.piml.utils.utility_functions import eta_quat_to_rad
from smarc_modelling.piml.pinn.pinn import init_pinn_model, pinn_predict
from smarc_modelling.lib.gnc import *
import os
import yaml

class BlueROV_PIML():
    def __init__(self, h = 0.1, piml_type = None):

        # PIML Related stuff
        self.piml_type = piml_type
        if self.piml_type == "pinn":
            print(f" Physics Informed Neural Network model initialized!")
            self.piml_model = init_pinn_model("brov_pinn.pt")


        # Thruster configuration
        config = self.load_file()
        selected_T_config = config['selected_T_matrix']
        self.T_matrix_options = config['T_matrices']
        self.T = np.array(self.T_matrix_options[selected_T_config])

        # Model properties
        self.g = 9.82           # Gravity
        self.rho = 1000         # Water density
        self.mass = 14          # Mass 
        self.nabla = 0.0134     # Water volume moved by ROV
        self.Ix = 0.26          # Inertia x-axis
        self.Iy = 0.23          # Inertia y-axis
        self.Iz = 0.37          # Inertia z-axis
        self.xg = 0             # Mass center relative mass center (?)
        self.yg = 0             # -||-
        self.zg = 0             # -||-
        self.xb = 0             # Buoyancy center relative mass center
        self.yb = 0             # -||-
        self.zb = -0.01         # -||-
        
        # Linear damping coefficients
        self.Xu = 13.7          # Linear damping coefficient for x-axis
        self.Yv = 0             # Linear damping coefficient for y-axis
        self.Zw = 33            # Linear damping coefficient for z-axis
        self.Kp = 0             # Linear damping coefficient for rotation round x-axis
        self.Mq = 0.8           # Linear damping coefficient for rotation round y-axis
        self.Nr = 0             # Linear damping coefficient for rotation round z-axis
        
        # Non-linear damping coefficients
        self.Xuu = 141          # Non-linear damping coefficient for x-axis
        self.Yvv = 217          # Non-linear damping coefficient for y-axis
        self.Zww = 190          # Non-linear damping coefficient for z-axis
        self.Kpp = 1.19         # Non-linear damping coefficient for rotation round x-axis
        self.Mqq = 0.47         # Non-linear damping coefficient for rotation round y-axis
        self.Nrr = 1.5          # Non-linear damping coefficient for rotation round z-axis
        
        # Added masses
        self.Xu_dot = 6.36      # Added mass x-axis
        self.Yv_dot = 7.12      # Added mass y-axis
        self.Zw_dot = 18.68     # Added mass z-axis
        self.Kp_dot = 0.189     # Added mass rotation x-axis
        self.Mq_dot = 0.135     # Added mass rotation y-axis
        self.Nr_dot = 0.222     # Added mass rotation z-axis

        # Misc
        self.gamma = 100 # Scaling factor for numerical stability of quaternion differentiation

    def dynamics(self, state, controls):

        eta = state[0:7]        # Pose
        nu = state[7:13]        # Velocities
        u_ref = state[13:19]    # Control reference
        u = controls            # Control commands
        
        self.get_angles(eta)
        self.calculate_M()      # Get the inertia matrix
        self.calculate_C(nu)    # Get the Coriolis matrix
        self.calculate_D(eta, nu, u) # Get the damping matrix
        self.calculate_tau(u)   # Get forces generated by thrusters
        self.calculate_g()   # Get buoyancy + gravity forces

        # print("Current set of forces")
        # print("FT: ", self.tau.T)
        # print("g:  ", self.g_vec.T)
        # print("Dv: ", np.matmul(nu, self.D).T)
        # print("Cv: ", np.matmul(nu, self.C).T)
        # print("\n")

        # print("D: ", self.D)
        # print("\n")

        # print(eta_quat_to_rad([1, 2, 3, 1, 0, 0, 1]))
        # print("\n")

        Dv = np.matmul(nu, self.D).reshape(-1, 1)
        Cv = np.matmul(nu, self.C).reshape(-1, 1)

        nu_dot = self.Minv @ (self.tau - Cv - Dv - self.g_vec).squeeze()
        u_dot = [0, 0, 0, 0, 0, 0, 0, 0] # We read this from the bag so no need to simulate
        eta_dot = self.eta_dynamics(eta, nu)
        
        x_dot = np.concatenate([eta_dot, nu_dot, u_dot])
        return x_dot

    def get_angles(self, eta):
        """
        Extract euler angles from quat
        """
        # Extract Euler angles
        eta = eta_quat_to_rad(eta)
        self.roll = eta[3]
        self.pitch = eta[4]
        self.yaw = eta[5]
        
    def calculate_M(self):
        """
        Calculate the inertia matrix as rigid body + added mass
        """
        # Rigid-body (RB) inertia
        m_diag = np.diag([self.mass, self.mass, self.mass]) # Mass
        I_matrix = np.diag([self.Ix, self.Iy, self.Iz])     # Inertia
        zeros = np.zeros((3, 3))                            # Filler
        M_RB = np.block([[m_diag, zeros], [zeros, I_matrix]]) # Rigid-body inertia

        # Added mass (A) inertia
        M_A = np.diag([self.Xu_dot, self.Yv_dot, self.Zw_dot, self.Kp_dot, self.Mq_dot, self.Nr_dot])

        # Full inertia matrix
        self.M = M_RB + M_A
        self.Minv = np.linalg.inv(self.M)

    def calculate_C(self, nu):
        """
        Calculates the Coriolis matrix based on current speed
        """

        # Get elements
        u = nu[0]
        v = nu[1]
        w = nu[2]
        p = nu[3]
        q = nu[4]
        r = nu[5]

        # Rigid body (RB) Coriolis matrix
        # Filler
        zeros = np.zeros((3, 3))
        # Inertia
        I_matrix = np.array([[        0, -self.Iz*r, -self.Iy*q],
                             [self.Iz*r,          0,  self.Ix*p],
                             [self.Iy*q, -self.Ix*p,          0]])
        # Masses
        mass_matrix = np.array([[           0,  self.mass*w, -self.mass*v],
                                [-self.mass*w,            0,  self.mass*u],
                                [ self.mass*v, -self.mass*u,            0]])    
        C_RB = np.block([[zeros, mass_matrix], [mass_matrix, I_matrix]])
        
        # Added mass (A) Coriolis matrix
        # Added masses
        mass_added = np.array([[             0, -self.Zw_dot*w,  self.Yv_dot*v],
                               [ self.Zw_dot*w,              0, -self.Xu_dot*u],
                               [-self.Yv_dot*v,  self.Xu_dot*u,              0]])
        # Added inertia
        I_added = np.array([[             0, -self.Nr_dot*r,  self.Mq_dot*q],
                            [ self.Nr_dot*r,              0, -self.Kp_dot*p],
                            [-self.Mq_dot*q,  self.Kp_dot*p,              0]])
        C_A = np.block([[zeros, mass_added], [mass_added, I_added]])

        self.C = C_RB + C_A

    def calculate_D(self, eta, nu, u_):
        """
        Calculate/Predict damping matrix based on current state
        """

        if self.piml_type == None:
            # White-box matrix
            
            # Get elements
            u = nu[0]
            v = nu[1]
            w = nu[2]
            p = nu[3]
            q = nu[4]
            r = nu[5]

            # Linear damping
            D_L = np.eye((6))
            D_L[0, 0] = self.Xu
            D_L[1, 1] = self.Yv
            D_L[2, 2] = self.Zw
            D_L[3, 3] = self.Kp
            D_L[4, 4] = self.Mq
            D_L[5, 5] = self.Nr
            
            # Quadratic damping
            D_Q = np.eye((6))
            D_Q[0, 0] = self.Xuu * abs(u)
            D_Q[1, 1] = self.Yvv * abs(v)
            D_Q[2, 2] = self.Zww * abs(w)
            D_Q[3, 3] = self.Kpp * abs(p)
            D_Q[4, 4] = self.Mqq * abs(q)
            D_Q[5, 5] = self.Nrr * abs(r)

            self.D = D_L + D_Q 

        elif self.piml_type == "pinn":
            print("PINN predicted D")
            self.D = pinn_predict(self.piml_model, eta, nu, u_)

    def calculate_tau(self, u):
        """
        Calculate the thruster forces
        """

        u = u.reshape((8, 1)) # Add dim
        u = (u - 1500) / 400 # Normalize PWM signals

        # Non-linear force expression
        F = -3.04338931856672*10e-13*u**5 + 2.27813523978448*10e-9*u**4 - 6.73710647138884*10e-6*u**3 + 0.00983670053385902*u**2 - 7.08023833982539*u + 2003.55692021905
        self.tau = np.matmul(self.T, F)

    def calculate_g(self):
        """
        Calculate buoyancy and gravitational forces
        """
        # Get angles, previously calculated from get_angles()
        phi = self.roll
        theta = self.pitch

        # Define forces
        W = self.mass * self.g # Gravity
        B = self.rho * self.g * self.nabla # Buoyancy

        g = np.zeros((6, 1))
        g[0] = (W-B) * np.sin(theta)
        g[1] = -(W-B) * np.cos(theta) * np.sin(phi)
        g[2] = -(W-B) * np.cos(theta) * np.cos(phi)
        g[3] = self.yb*B*np.cos(theta)*np.cos(phi)-(self.zb*B*np.cos(theta)*np.sin(phi))
        g[4] = -self.zb*B*np.sin(theta)-(self.xb*B*np.cos(theta)*np.cos(phi))
        g[5] = self.xb*B*np.cos(theta)*np.sin(phi)+(self.yb*B*np.sin(theta))

        self.g_vec = g

    def eta_dynamics(self, eta, nu):
        """
        Computes the time derivative of position and quaternion orientation
        """
        q = eta[3:7]
        q = q/np.linalg.norm(q)

        # Convert quaternion to DCM for position kinematics
        C = quaternion_to_dcm(q)

        # Fossen position dynamics
        pos_dot = C @ nu[0:3]
        om = nu[3:6]
        q0, q1, q2, q3 = q
        T_q_n_b = 0.5 * np.array([
                                 [-q1, -q2, -q3],
                                 [q0, -q3, q2],
                                 [q3, q0, -q1],
                                 [-q2, q1, q0]
                                 ])
        q_dot = T_q_n_b @ om + self.gamma/2 * (1 - q.T.dot(q)) * q

        return np.concatenate([pos_dot, q_dot])

    # Backwards compatibility stuff from rewriting the code
    def create_M(self):
        self.calculate_M()
        return self.M
    def create_C(self, nu):
        self.calculate_C(nu)
        return self.C
    def create_g(self, eta):
        self.get_angles(eta)
        self.calculate_g()
        return self.g_vec
    def create_F(self, u):
        self.calculate_tau(u)
        return self.tau

    def load_file(self):
        script_dir = os.path.dirname(os.path.realpath(__file__))
        config_dir = os.path.join(script_dir, '..', 'piml', 'brov', 'config')
        mpc_param_file = config_dir+"/MPC_Params.yaml"
        # print("script: "+ mpc_param_file)
        # print(os.path.isfile(mpc_param_file))
        with open(mpc_param_file, "r") as file:
            config = yaml.safe_load(file)
        return config
